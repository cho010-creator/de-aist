<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>연금술사의 의뢰서</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cute+Font&family=Gaegu:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* FINAL DESIGN V4 - Starlit Magic Shop Theme */
        @keyframes glow { 0%, 100% { box-shadow: 0 0 10px #fef08a, 0 0 20px #fef08a; } 50% { box-shadow: 0 0 20px #fde68a, 0 0 30px #fde68a; } }
        @keyframes card-deal { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }

        body {
            font-family: 'Gaegu', cursive;
            background-image: url('https://www.transparenttextures.com/patterns/stardust.png'), linear-gradient(to bottom, #0f172a, #1e293b);
            color: #e2e8f0;
            font-weight: 700;
            font-size: 1.1rem;
            overflow: hidden; /* Prevent scrolling */
        }
        .font-title {
            font-family: 'Cute Font', cursive;
            color: #fde68a;
            text-shadow: 2px 2px 5px rgba(251, 191, 36, 0.5);
        }
        .screen {
            width: 100%; height: 100vh;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s ease-in-out; position: absolute; top: 0; left: 0;
            padding: 1rem;
        }
        .screen.hidden { opacity: 0; pointer-events: none; }

        .card {
            width: 90px; height: 130px;
            background-image: url('https://www.transparenttextures.com/patterns/book.png'), linear-gradient(to top, #f8fafc, #e2e8f0);
            color: #1e293b; border: 3px solid #94a3b8; border-radius: 10px;
            display: flex; flex-direction: column; justify-content: space-between; padding: 8px 4px;
            cursor: pointer; transition: all 0.2s ease-in-out;
            box-shadow: 0 5px 10px rgba(0,0,0,0.3); position: relative; user-select: none;
            animation: card-deal 0.5s ease-out backwards;
        }
        .card:hover { transform: translateY(-5px) scale(1.05); border-color: #facc15; }
        .card.selected { border-color: #4ade80; transform: translateY(-10px) scale(1.1); box-shadow: 0 0 20px #4ade80; }
        .card .number { font-family: 'Cute Font', cursive; font-size: 1.8rem; line-height: 1; }
        .card .icon { font-size: 1.5rem; }
        .card .name { font-size: 0.75rem; font-weight: 700; text-align: center; line-height: 1.1; }
        .card .checkmark { position: absolute; top: 5px; right: 5px; display: none; font-size: 1.5rem; }
        .card.selected .checkmark { display: block; }
        
        .opponent-card { background-image: url('https://www.transparenttextures.com/patterns/binding-dark.png'), linear-gradient(to bottom, #475569, #334155); cursor: default; border-color: #64748b;}
        .opponent-card .number, .opponent-card .icon, .opponent-card .name { display: none; }

        .recipe-card {
            background-image: url('https://www.transparenttextures.com/patterns/scroll-insets.png'), linear-gradient(to bottom right, #f3e8ff, #e9d5ff);
            color: #581c87; border: 3px solid #a855f7; border-radius: 10px; padding: 12px;
            transition: all 0.2s ease-in-out; box-shadow: 0 4px 6px rgba(0,0,0,0.4); text-align: center;
        }
        .recipe-card.possible { border-color: #f59e0b; box-shadow: 0 0 15px #f59e0b; cursor: pointer; animation: glow 1.5s infinite; }
        .recipe-card.possible:hover { transform: scale(1.05); background: linear-gradient(to bottom, #fcd34d, #fbbf24); }
        .recipe-card .recipe-name { font-family: 'Cute Font', cursive; font-size: 1.6rem; line-height: 1.1; color: #7e22ce;}
        .recipe-card .recipe-details { font-size: 0.8rem; }
        .recipe-card .recipe-points { font-family: 'Cute Font', cursive; font-size: 1.4rem; color: #1d4ed8;}
        .recipe-card .flavor-text { font-size: 0.7rem; font-style: italic; margin-top: 4px; color: #581c87; opacity: 0.8; }

        .game-board { display: flex; flex-direction: column; height: 100vh; padding: 8px; width: 100%; max-width: 1400px; margin: 0 auto; }
        .player-area { flex-shrink: 0; display: flex; justify-content: center; align-items: center; gap: 10px; padding: 8px; min-height: 180px; }
        .center-area { flex-grow: 1; min-height: 0; display: flex; justify-content: space-around; align-items: center; gap: 16px; width: 100%;}
        .deck-area { display: flex; flex-direction: column; align-items: center; gap: 8px; }
        
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.75); display: flex; justify-content: center; align-items: center; z-index: 100; backdrop-filter: blur(5px); }
        .modal-content {
            background-image: url('https://www.transparenttextures.com/patterns/stardust.png'), linear-gradient(to bottom right, #4c1d95, #3b0764);
            padding: 40px; border-radius: 15px; border: 5px solid #d8b4fe;
            text-align: center; max-width: 90%; width: 500px; box-shadow: 0 0 40px rgba(216, 180, 254, 0.5);
        }

        .button {
            font-family: 'Cute Font', cursive; font-size: 1.7rem;
            background: linear-gradient(to bottom, #6366f1, #4f46e5);
            color: #e0e7ff; padding: 5px 25px; border-radius: 50px;
            border: 2px solid #818cf8; border-bottom: 5px solid #312e81;
            cursor: pointer; transition: all 0.1s ease-in-out;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        .button:hover { transform: translateY(-2px); border-bottom-width: 7px; background: linear-gradient(to bottom, #818cf8, #6366f1); }
        .button:active { transform: translateY(2px); border-bottom-width: 3px; }
        .button:disabled { opacity: 0.6; cursor: not-allowed; filter: grayscale(1); transform: translateY(0); border-bottom-width: 5px; }
    </style>
</head>
<body>

<!-- Start Screen -->
<div id="start-screen" class="screen">
    <div class="text-center">
        <h1 class="font-title text-9xl mb-4">연금술사의 의뢰서</h1>
        <p class="text-3xl mb-12">마법의 재료를 모아 신비로운 물약을 만드세요!</p>
        <div class="space-y-4">
            <button id="start-ai-btn" class="button w-72">혼자하기 (AI 대전)</button>
            <button id="create-game-btn" class="button w-72">게임 만들기 (친구와 함께)</button>
            <div class="flex justify-center items-center gap-2">
                <input type="text" id="join-code-input" placeholder="참여 코드" maxlength="6" class="w-48 rounded-md">
                <button id="join-game-btn" class="button">참여하기</button>
            </div>
        </div>
    </div>
</div>

<!-- Lobby Screen -->
<div id="lobby-screen" class="screen hidden">
    <div class="modal-content">
        <h2 class="font-title text-5xl mb-4">마법 동료 기다리는 중...</h2>
        <p class="mb-6 text-2xl">이 코드를 친구에게 알려주세요:</p>
        <p id="game-code-display" class="text-6xl font-bold bg-slate-900/50 p-4 rounded-lg tracking-widest"></p>
        <p class="mt-6 animate-pulse text-xl">친구가 참여하면 게임이 시작됩니다.</p>
    </div>
</div>


<!-- Game Screen & Modals -->
<div id="game-screen" class="game-board hidden">
    <div class="player-area"><div class="text-center"><h2 class="font-title text-4xl text-red-400">라이벌</h2><div id="opponent-hand" class="flex gap-2 mt-2 flex-wrap justify-center"></div><p class="text-2xl mt-2">점수: <span id="opponent-score">0</span></p></div></div>
    <div class="center-area py-2">
        <div class="deck-area"><div id="deck" class="card"><div class="font-title text-3xl">서고</div><div id="deck-count" class="text-lg"></div></div><button id="draw-deck-btn" class="button">재료 뽑기</button></div>
        <div id="recipe-board" class="flex-grow grid grid-cols-1 md:grid-cols-3 gap-4 w-full"></div>
        <div class="deck-area"><div id="discard-pile-container" class="relative w-[90px] h-[130px]"></div><button id="draw-discard-btn" class="button">폐기물 줍기</button></div>
    </div>
    <div class="player-area"><div class="text-center"><div class="flex items-center gap-4 mb-2"><button id="discard-btn" class="button">재료 버리기</button><h2 class="font-title text-4xl text-amber-300">나의 손패</h2></div><div id="player-hand" class="flex gap-2 mt-2 flex-wrap justify-center"></div><p class="text-2xl mt-2">점수: <span id="player-score">0</span></p></div></div>
</div>

<div id="tutorial-modal" class="modal hidden"><div class="modal-content"><h2 id="tutorial-title" class="font-title text-5xl mb-4"></h2><p id="tutorial-text" class="text-2xl mb-8"></p><button id="tutorial-next-btn" class="button">다음</button></div></div>
<div id="message-modal" class="modal hidden"><div class="modal-content"><h2 id="message-title" class="font-title text-5xl mb-4"></h2><p id="message-text" class="text-2xl mb-8"></p><button id="message-button" class="button">확인</button></div></div>

<script type="module">
    // --- FINAL STABLE & SIMPLE GAME LOGIC ---
    
    const WINNING_SCORE = 10;
    const ICONS = ['📜', '🕯️', '💧', '🌿', '💎', '🦉', '🗝️', '✨', '✒️', '🍄'];
    const INGREDIENT_NAMES = ["고대 주문서", "용의 숨결 양초", "인어의 눈물", "만드라고라 잎", "별빛 다이아몬드", "현자의 깃털", "비밀의 열쇠", "요정 가루", "그리핀의 깃펜", "웃음 버섯"];
    let state = {};
    let selectedCards = [];

    const screens = { start: document.getElementById('start-screen'), lobby: document.getElementById('lobby-screen'), game: document.getElementById('game-screen') };
    const playerHandEl = document.getElementById('player-hand'), opponentHandEl = document.getElementById('opponent-hand'),
          recipeBoardEl = document.getElementById('recipe-board'), deckCountEl = document.getElementById('deck-count'),
          discardPileContainer = document.getElementById('discard-pile-container'), playerScoreEl = document.getElementById('player-score'),
          opponentScoreEl = document.getElementById('opponent-score'), drawDeckBtn = document.getElementById('draw-deck-btn'),
          drawDiscardBtn = document.getElementById('draw-discard-btn'), discardBtn = document.getElementById('discard-btn');
    
    const findCombinations = (arr, k) => { if (k > arr.length || k <= 0) return []; if (k === arr.length) return [arr]; if (k === 1) return arr.map(item => [item]); const c = []; arr.forEach((item, i) => { findCombinations(arr.slice(i + 1), k - 1).forEach(sc => c.push([item, ...sc])); }); return c; };
    const createDeck = () => Array.from({ length: 100 }, (_, i) => ({ id: `card-${i+1}`, number: i + 1, icon: ICONS[(i + 1) % 10], name: INGREDIENT_NAMES[(i+1) % 10] }));
    const createRecipes = () => [ { id: 'r1', name: "기초 회복 물약", details: "끝자리 같은 재료 2장", points: 1, flavor: "초보 연금술사의 첫걸음.", condition: (c) => findCombinations(c, 2).find(d => d[0].number % 10 === d[1].number % 10) }, { id: 'r2', name: "열정의 비약", details: "합이 50이 되는 재료 2장", points: 1, flavor: "마시면 심장이 두근거린다.", condition: (c) => findCombinations(c, 2).find(d => d[0].number + d[1].number === 50) }, { id: 'r3', name: "마법 촉매", details: "연속된 숫자 재료 3장", points: 3, flavor: "더 강력한 마법을 위한 필수품.", condition: (c) => { const s=c.slice().sort((a,b)=>a.number-b.number); for(let i=0;i<=s.length-3;i++) if(s[i+1].number===s[i].number+1&&s[i+2].number===s[i].number+2) return [s[i],s[i+1],s[i+2]]; return null; }}, { id: 'r4', name: "수호의 부적", details: "끝자리 같은 재료 3장", points: 3, flavor: "악한 기운을 막아준다.", condition: (c) => findCombinations(c, 3).find(d => d.every(e => e.number % 10 === d[0].number % 10)) }, { id: 'r5', name: "현자의 돌 조각", details: "짝수 5장 (합 100 이상)", points: 5, flavor: "만물의 근원이 되는 물질의 파편.", condition: (c) => findCombinations(c.filter(d=>d.number%2===0),5).find(d=>d.reduce((s,i)=>s+i.number,0)>=100) }, { id: 'r6', name: "궁극의 엘릭서", details: "연속된 숫자 6장", points: 7, flavor: "전설 속에만 존재하는 완벽한 물약.", condition: (c) => { const s=c.slice().sort((a,b)=>a.number-b.number); for(let i=0;i<=s.length-6;i++) { let q=true; for(let j=1;j<6;j++) if(s[i+j].number!==s[i].number+j){q=false;break;} if(q)return s.slice(i,i+6)} return null; }} ].sort(() => 0.5 - Math.random());

    const tutorialSteps = [
        { title: "환영합니다!", text: "게임 목표는 '의뢰서'를 완성해 10점을 먼저 얻는 것입니다." },
        { title: "차례 (1/3)", text: "차례가 되면 '재료 뽑기'로 서고에서 카드를 가져오세요." },
        { title: "차례 (2/3)", text: "손에 있는 카드를 여러 장 선택하고, 조건이 맞는 '의뢰서'를 클릭하면 점수를 얻습니다." },
        { title: "차례 (3/3)", text: "차례를 마치려면, 손에서 버릴 카드 1장을 선택한 뒤 '재료 버리기' 버튼을 누르세요." },
        { title: "행운을 빌어요!", text: "이제 당신의 실력을 보여주세요! 게임을 시작합니다." }
    ];
    let tutorialStep = 0;

    function showTutorial(onComplete) {
        tutorialStep = 0;
        const modal = document.getElementById('tutorial-modal');
        const titleEl = document.getElementById('tutorial-title');
        const textEl = document.getElementById('tutorial-text');
        const nextBtn = document.getElementById('tutorial-next-btn');
        
        function updateStep() {
            titleEl.textContent = tutorialSteps[tutorialStep].title;
            textEl.textContent = tutorialSteps[tutorialStep].text;
            nextBtn.textContent = (tutorialStep === tutorialSteps.length - 1) ? "시작하기!" : "다음";
        }

        nextBtn.onclick = () => {
            tutorialStep++;
            if (tutorialStep < tutorialSteps.length) {
                updateStep();
            } else {
                modal.classList.add('hidden');
                onComplete();
            }
        };

        updateStep();
        modal.classList.remove('hidden');
    }

    function showScreen(screenName) { Object.values(screens).forEach(s => s.classList.add('hidden')); screens[screenName].classList.remove('hidden'); }
    function setState(newState) { state.turnState = newState; updateUI(); }
    
    function startAiGame() {
        showScreen('game');
        state = { players: { player: { score: 0, hand: [] }, opponent: { score: 0, hand: [] } }, deck: createDeck().sort(() => 0.5 - Math.random()), recipeDeck: createRecipes(), boardRecipes: [], discardPile: [], activePlayer: 'player', turnState: 'INIT' };
        for (let i=0; i<7; i++) { state.players.player.hand.push(state.deck.pop()); state.players.opponent.hand.push(state.deck.pop()); }
        for (let i=0; i<3; i++) { if (state.recipeDeck.length > 0) state.boardRecipes.push(state.recipeDeck.pop()); }
        if (state.deck.length > 0) state.discardPile.push(state.deck.pop());
        
        showTutorial(() => {
            setState('ACTION');
        });
        updateUI();
    }

    function playerAction(type, data) {
        if (state.activePlayer !== 'player' || state.turnState.includes('OPPONENT') || state.turnState === 'GAME_OVER') return;

        if (type === 'drawDeck') {
            if (state.turnState !== 'ACTION') return;
            if (state.deck.length > 0) { state.players.player.hand.push(state.deck.pop()); setState('DISCARD'); }
        } else if (type === 'drawDiscard') {
            if (state.turnState !== 'ACTION') return;
            if (state.discardPile.length > 0) {
                state.players.player.hand.push(state.discardPile.pop());
                setState('DISCARD_NO_RECIPE');
            }
        } else if (type === 'discard') {
            if (!state.turnState.includes('DISCARD')) return;
            if (selectedCards.length !== 1) { showMessage("알림", "버릴 카드 1장을 선택해주세요."); return; }
            const card = selectedCards[0];
            state.players.player.hand = state.players.player.hand.filter(c => c.id !== card.id);
            state.discardPile.push(card);
            selectedCards = [];
            switchTurn();
        } else if (type === 'completeRecipe') {
            if (state.turnState !== 'DISCARD') { showMessage("알림", "카드를 먼저 뽑아야 연성할 수 있습니다."); return; }
            const { recipe, index } = data;
            const cardsToUse = recipe.condition(selectedCards);
            if (cardsToUse) {
                showMessage("연성 성공!", `'${recipe.name}'을 완성하여 ${recipe.points}점을 얻었습니다!`);
                cardsToUse.forEach(used => { state.players.player.hand = state.players.player.hand.filter(h => h.id !== used.id); });
                state.players.player.score += recipe.points;
                selectedCards = [];
                if (state.recipeDeck.length > 0) state.boardRecipes[index] = state.recipeDeck.pop(); else state.boardRecipes.splice(index, 1);
                if (checkWin()) return;
                updateUI();
            } else {
                showMessage("연성 실패", "선택한 카드로는 이 의뢰서를 완성할 수 없습니다.");
            }
        }
    }
    
    function switchTurn() { state.activePlayer = state.activePlayer === 'player' ? 'opponent' : 'player'; if (state.activePlayer === 'opponent') { setState('OPPONENT_THINKING'); setTimeout(handleAiTurn, 2000); } else { setState('ACTION'); } }

    function handleAiTurn() {
        let actionTaken = false;
        const sortedRecipes = state.boardRecipes.slice().sort((a, b) => b.points - a.points);
        for (const recipe of sortedRecipes) {
            const cardsToUse = recipe.condition(state.players.opponent.hand);
            if (cardsToUse) {
                actionTaken = true;
                showMessage("상대 연성!", `상대가 '${recipe.name}'을 완성했습니다!`);
                cardsToUse.forEach(used => { state.players.opponent.hand = state.players.opponent.hand.filter(h => h.id !== used.id); });
                state.players.opponent.score += recipe.points;
                const rIndex = state.boardRecipes.findIndex(r => r.id === recipe.id);
                if (state.recipeDeck.length > 0) state.boardRecipes[rIndex] = state.recipeDeck.pop(); else state.boardRecipes.splice(rIndex, 1);
                if (checkWin()) return;
            }
        }
        
        if (state.deck.length > 0) {
            const topDiscard = state.discardPile.length > 0 ? state.discardPile[state.discardPile.length - 1] : null;
            let willTakeDiscard = false;
            if (topDiscard) {
                for (const recipe of state.boardRecipes) {
                    if (recipe.condition([...state.players.opponent.hand, topDiscard])) {
                        willTakeDiscard = true;
                        break;
                    }
                }
            }
            if (willTakeDiscard) {
                state.players.opponent.hand.push(state.discardPile.pop());
            } else {
                state.players.opponent.hand.push(state.deck.pop());
            }
        }

        if (state.players.opponent.hand.length > 0) {
            const cardToDiscard = state.players.opponent.hand.sort((a,b) => a.number - b.number)[0];
            state.players.opponent.hand = state.players.opponent.hand.filter(c => c.id !== cardToDiscard.id);
            state.discardPile.push(cardToDiscard);
        }

        if (!actionTaken) showMessage("상대 턴 종료", "상대가 카드를 버리고 차례를 마쳤습니다.");
        switchTurn();
    }
    
    function checkWin() { if (state.players.player.score >= WINNING_SCORE) { setState("GAME_OVER"); showMessage("승리!", "당신이 최고의 연금술사입니다!", startAiGame); return true; } if (state.players.opponent.score >= WINNING_SCORE) { setState("GAME_OVER"); showMessage("패배", "상대가 먼저 궁극의 연금술에 도달했습니다.", startAiGame); return true; } return false; }

    function updateUI() {
        if (!state.players) return;
        playerHandEl.innerHTML = '';
        state.players.player.hand.sort((a,b)=>a.number-b.number).forEach(card => {
            const el = document.createElement('div'); el.className = 'card';
            if (selectedCards.some(c => c.id === card.id)) el.classList.add('selected');
            el.innerHTML = `<div class="number">${card.number}</div><div class="icon">${card.icon}</div><div class="name">${card.name}</div><div class="checkmark">✅</div>`;
            el.onclick = () => { if (state.activePlayer !== 'player') return; const idx = selectedCards.findIndex(c => c.id === card.id); if (idx > -1) selectedCards.splice(idx, 1); else selectedCards.push(card); updateUI(); };
            playerHandEl.appendChild(el);
        });

        opponentHandEl.innerHTML = '';
        state.players.opponent.hand.forEach(() => { const el = document.createElement('div'); el.className = 'card opponent-card'; opponentHandEl.appendChild(el); });

        recipeBoardEl.innerHTML = '';
        state.boardRecipes.forEach((recipe, index) => {
             const el = document.createElement('div'); el.className = 'recipe-card';
             el.innerHTML = `<div class="recipe-name">${recipe.name}</div><div class="recipe-details">${recipe.details}</div><p class="flavor-text">"${recipe.flavor}"</p><div class="recipe-points">${recipe.points}점</div>`;
             if (state.turnState === 'DISCARD' && recipe.condition(selectedCards)) el.classList.add('possible');
             el.onclick = () => playerAction('completeRecipe', { recipe, index });
             recipeBoardEl.appendChild(el);
        });
        
        discardPileContainer.innerHTML = '';
        state.discardPile.forEach((card, i) => { const el = document.createElement('div'); el.className = 'card'; el.style.position='absolute'; el.style.bottom=`${Math.min(i*4,20)}px`; el.innerHTML=`<div class="number">${card.number}</div><div class="icon">${card.icon}</div><div class="name">${card.name}</div>`; discardPileContainer.appendChild(el); });
        
        deckCountEl.innerText = state.deck.length;
        playerScoreEl.innerText = state.players.player.score;
        opponentScoreEl.innerText = state.players.opponent.score;

        const isPlayerTurn = state.activePlayer === 'player';
        drawDeckBtn.disabled = !isPlayerTurn || state.turnState !== 'ACTION';
        drawDiscardBtn.disabled = !isPlayerTurn || state.turnState !== 'ACTION';
        discardBtn.disabled = !isPlayerTurn || !state.turnState.includes('DISCARD') || selectedCards.length === 0;
    }
    
    function showMessage(title, text, callback) { const modal = document.getElementById('message-modal'); document.getElementById('message-title').textContent = title; document.getElementById('message-text').textContent = text; modal.classList.remove('hidden'); document.getElementById('message-button').onclick = () => { modal.classList.add('hidden'); if(callback) callback(); }; }

    function initialize() {
        document.getElementById('start-ai-btn').onclick = startAiGame;
        document.getElementById('create-game-btn').onclick = () => {
            const gameCode = Math.random().toString(36).substring(2, 8).toUpperCase();
            document.getElementById('game-code-display').textContent = gameCode;
            showScreen('lobby');
        };
        document.getElementById('join-game-btn').onclick = () => showMessage("준비 중!", "코드로 참여하기 기능은 다음 업데이트를 기대해주세요!");
        
        drawDeckBtn.onclick = () => playerAction('drawDeck');
        drawDiscardBtn.onclick = () => playerAction('drawDiscard');
        discardBtn.onclick = () => playerAction('discard');
    }
    initialize();
</script>

</body>
</html>

